---
layout: post
title: EventBus 分析笔记
category: 学习
tags: KIDLOSERME
keywords: EventBus简要分析
description: 
---

之前看过EventBus的源码，不是很深入，导致有些模糊，此次仔细阅读了一下，记录笔记，方便以后熟悉。
从register说起：<br>
```java
private synchronized void register(Object subscriber, boolean sticky, int priority) {
	//查找subscriber（执行register的类）中注册事件的方法，onEvent开头，参数只允许一个，超过一个将被忽略
   List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriber.getClass());
   for (SubscriberMethod subscriberMethod : subscriberMethods) {
       //根据事件类型以及订阅类进行数据处理
       subscribe(subscriber, subscriberMethod, sticky, priority);
   }
}
```
findSubscriberMethods这个方法很长，大致要做的事情就是查找出该类以及其父类中声明的所有方法，根据规则（只能public修饰onEvent开头且只有一个参数）筛选出订阅方法，一起看一下吧，具体就在代码中写说明了，删除了部分代码限制篇幅：<br>
```java
List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
	//省略部分代码
   subscriberMethods = new ArrayList<SubscriberMethod>();
   Class<?> clazz = subscriberClass;
   HashSet<String> eventTypesFound = new HashSet<String>();
   StringBuilder methodKeyBuilder = new StringBuilder();
   while (clazz != null) {
       String name = clazz.getName();
       //忽略系统类
       if (name.startsWith("java.") || name.startsWith("javax.") || name.startsWith("android.")) {
           break;
       }
       //获取该类中声明的所有方法
       Method[] methods = clazz.getDeclaredMethods();
       for (Method method : methods) {
           String methodName = method.getName();
           //是否以onEvent开头
           if (methodName.startsWith(ON_EVENT_METHOD_NAME)) {
               int modifiers = method.getModifiers();
               //修饰符只能以public开头
               if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
                   Class<?>[] parameterTypes = method.getParameterTypes();
                   //只能有一个参数
                   if (parameterTypes.length == 1) {
                       String modifierString = methodName.substring(ON_EVENT_METHOD_NAME.length());
                       ThreadMode threadMode;
                       //获取线程执行方式
                       if (modifierString.length() == 0) {
                           threadMode = ThreadMode.PostThread;
                       } else if (modifierString.equals("MainThread")) {
                           threadMode = ThreadMode.MainThread;
                       } else if (modifierString.equals("BackgroundThread")) {
                           threadMode = ThreadMode.BackgroundThread;
                       } else if (modifierString.equals("Async")) {
                           threadMode = ThreadMode.Async;
                       } else {
                       	//省略部分代码
                       }
                       Class<?> eventType = parameterTypes[0];
                       methodKeyBuilder.setLength(0);
                       methodKeyBuilder.append(methodName).append('>').append(eventType.getName());
                       String methodKey = methodKeyBuilder.toString();
                       //检查是否已经添加过
                       if (eventTypesFound.add(methodKey)) {
                           // Only add if not already found in a sub class
                       	//添加到列表中
                           subscriberMethods.add(new SubscriberMethod(method, threadMode, eventType));
                       }
                   }
               } else if (!skipMethodVerificationForClasses.containsKey(clazz)) {
                   Log.d(EventBus.TAG, "Skipping method (not public, static or abstract): " + clazz + "."
                           + methodName);
               }
           }
       }
       //获取父类并且继续查找父类中的订阅方法
       clazz = clazz.getSuperclass();
   }
   //省略部分代码
}
```
接下来看subscribe(subscriber, subscriberMethod, sticky, priority);这个方法是干啥的，总结来说就是把所有事件类型为eventType的订阅者放入List列表中，并放入Map集合中。然后再根据订阅事件的类构造一个订阅事件列表，用来判断某个类是否已经注册过事件,看一下代码：
```java
明天写
```


