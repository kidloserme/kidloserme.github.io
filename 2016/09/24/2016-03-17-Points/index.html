<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Holo Wang"><meta name="description" content="HaspMap原理根据key的hashCode与Enty[]长度取模获取index来决定放入Enty中的位置，index重复则使用Entry.next在同一个index中放入多个值具体可看：http://www.cnblogs.com/xwdreamer/archive/2012"><meta name="keywords" content=""><title>知识点总结 · 加贝龙</title><link rel="icon" href="/long_02.jpg"><link rel="canonical" href="http://yoursite.com/2016/09/24/2016-03-17-Points/"><link rel="alternate" href="/atom.xml" title="加贝龙"><link rel="stylesheet" href="/fonts/iconfont/iconfont.css"><link rel="stylesheet" href="/css/style.css"></head><body><div id="main"><header><a href="/." class="logo">加贝龙</a><ul class="nav"><li class="nav-link"><a href="/" target="_self">首页</a></li><li class="nav-link"><a href="/archives/" target="_self">归档</a></li><li class="nav-link"><a href="/categories/" target="_self">分类</a></li><li class="nav-link"><a href="/tags/" target="_self">标签</a></li><li class="nav-link"><a href="/about/" target="_self">关于</a></li></ul></header><section id="container"><article class="post"><h1 class="post-title">知识点总结</h1><span class="post-time">2016年9月24日</span><div id="sidebar" class="post-sidebar"><h3 class="heading">目录</h3><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#HaspMap原理"><span class="toc-text">HaspMap原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap和HashTable的区别"><span class="toc-text">HashMap和HashTable的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-TreeMap-LinkedHashMap-元素顺序"><span class="toc-text">HashMap TreeMap  LinkedHashMap 元素顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List子类ArrayList-LinkedList-Vector"><span class="toc-text">List子类ArrayList LinkedList  Vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet"><span class="toc-text">HashSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map-List-Set"><span class="toc-text">Map List Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关键字transient："><span class="toc-text">关键字transient：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一个关于线程的问题"><span class="toc-text">一个关于线程的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait和notify："><span class="toc-text">wait和notify：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程通信"><span class="toc-text">线程通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Volatile的官方定义"><span class="toc-text">Volatile的官方定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池"><span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#参数介绍："><span class="toc-text">参数介绍：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#要点："><span class="toc-text">要点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程池创建"><span class="toc-text">线程池创建</span></a></li></ol></li></ol></div><div class="post-content"><h3 id="HaspMap原理"><a href="#HaspMap原理" class="headerlink" title="HaspMap原理"></a>HaspMap原理</h3><p>根据key的hashCode与Enty[]长度取模获取index来决定放入Enty中的位置，index重复则使用Entry.next在同一个index中放入多个值<br>具体可看：<a href="http://www.cnblogs.com/xwdreamer/archive/2012/05/14/2499339.html" target="_blank" rel="external">http://www.cnblogs.com/xwdreamer/archive/2012/05/14/2499339.html</a> 介绍</p>
<h3 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h3><p>HaspMap继承AbstractMap ，HashTable继承Dictionary<br>HashMap的方法不是同步的，HashTable的方法是同步的<br>HashMap允许key和value为Null，HashTable不允许key和value为null<br>详见：<a href="http://blog.csdn.net/shohokuf/article/details/3932967" target="_blank" rel="external">http://blog.csdn.net/shohokuf/article/details/3932967</a></p>
<a id="more"></a>
<h3 id="HashMap-TreeMap-LinkedHashMap-元素顺序"><a href="#HashMap-TreeMap-LinkedHashMap-元素顺序" class="headerlink" title="HashMap TreeMap  LinkedHashMap 元素顺序"></a>HashMap TreeMap  LinkedHashMap 元素顺序</h3><p>HashMap不保证元素的插入顺序，TreeMap默认会按照key的升序排序TreeMap支持自定义排序，LinkedHashMap按照插入顺序排序</p>
<h3 id="List子类ArrayList-LinkedList-Vector"><a href="#List子类ArrayList-LinkedList-Vector" class="headerlink" title="List子类ArrayList LinkedList  Vector"></a>List子类ArrayList LinkedList  Vector</h3><p>LinkedList在 add和remove 上更快,而在get上更慢.<br>List接口下一共实现了三个类：ArrayList，Vector，LinkedList。LinkedList就不多说了，它一般主要用在保持数据的插入顺序的时候。<br>ArrayList和Vector都是用数组实现的，主要有这么三个区别：</p>
<ul>
<li>1、Vector是多线程安全的，而ArrayList不是，这个可以从源码中看出，Vector类中的方法很多有synchronized进行修饰，这样就导致了Vector在效率上无法与ArrayList相比；</li>
<li>2、两个都是采用的线性连续空间存储元素，但是当空间不足的时候，两个类的增加方式是不同的，很多网友说Vector增加原来空间的一倍，ArrayList增加原来空间的50%，其实也差不多是这个意思，不过还有一点点问题可以从源码中看出，一会儿从源码中分析。</li>
<li>3、Vector可以设置增长因子，而ArrayList不可以，最开始看这个的时候，我没理解什么是增量因子，不过通过对比一下两个源码理解了这个，先看看两个类的构造方法：</li>
</ul>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>HashSet内部实际上是一个HashMap，看代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">transient</span> HashMap&lt;E, HashSet&lt;E&gt;&gt; backingMap;</div><div class="line">看添加代码：</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E object)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> backingMap.put(object, <span class="keyword">this</span>) == <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//所以Set几何不允许重复的元素存在</span></div></pre></td></tr></table></figure>
<h3 id="Map-List-Set"><a href="#Map-List-Set" class="headerlink" title="Map List Set"></a>Map List Set</h3><ul>
<li>Map内部是一个Entry数组；</li>
<li>List内部是一个Object数组；</li>
<li>Set内部是一个Map集合，map的key集合就是Set的Value集合</li>
</ul>
<h3 id="关键字transient："><a href="#关键字transient：" class="headerlink" title="关键字transient："></a>关键字transient：</h3><ul>
<li>1）一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。</li>
<li>2）transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。</li>
<li>3）被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。</li>
</ul>
<h3 id="一个关于线程的问题"><a href="#一个关于线程的问题" class="headerlink" title="一个关于线程的问题"></a>一个关于线程的问题</h3><p>假如有Thread1、Thread2、Thread3、Thread4四条线程分别统计C、D、E、F四个盘的大小，所有线程都统计完毕交给Thread5线程去做汇总，应当如何实现？<br>可以使用并发包下的CountDownLatch实现<br><a href="http://www.cnblogs.com/dolphin0520/p/3920397.html" target="_blank" rel="external">http://www.cnblogs.com/dolphin0520/p/3920397.html</a></p>
<h3 id="wait和notify："><a href="#wait和notify：" class="headerlink" title="wait和notify："></a>wait和notify：</h3><p>执行wait、notify必须在同步块内部，这两个动作都是针对某一个对象的，比如对象A在线程1中执行了wait，那么线程1就会停留在此处，类似于阻塞，然后A在线程2中调用了notify，并且线程2执行结束之后线程1继续执行，如果对象A不在某处调用notify，线程1会一直停留在wait那一行处不继续执行。或者A调用wait的时候传一个等待时间，如果在这个等待时间内notify没有被调用，线程1会恢复执行。如果对象A在多个线程调用wait，那么必须执行notifyAll才能唤醒所有等待的线程，否则只会喊醒其中一个。</p>
<h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><p>线程之间的通信机制:(共享内存、消息传递)<br>深入理解Java内存模型<a href="http://www.infoq.com/cn/articles/java-memory-model-1" target="_blank" rel="external">http://www.infoq.com/cn/articles/java-memory-model-1</a></p>
<h3 id="Volatile的官方定义"><a href="#Volatile的官方定义" class="headerlink" title="Volatile的官方定义"></a>Volatile的官方定义</h3><p>Java语言规范第三版中对volatile的定义如下： java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>为什么要使用线程池<br>避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。<br>从Java5开始，Java提供了自己的线程池。每次只执行指定数量的线程，java.util.concurrent.ThreadPoolExecutor<br>public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<runnable> workQueue,RejectedExecutionHandler handler);   </runnable></p>
<h4 id="参数介绍："><a href="#参数介绍：" class="headerlink" title="参数介绍："></a>参数介绍：</h4><ul>
<li>corePoolSize 核心线程数，指保留的线程池大小（不超过maximumPoolSize值时，线程池中最多有corePoolSize 个线程工作）。 </li>
<li>maximumPoolSize 指的是线程池的最大大小（线程池中最大有corePoolSize 个线程可运行）。 </li>
<li>keepAliveTime 指的是空闲线程结束的超时时间（当一个线程不工作时，过keepAliveTime 长时间将停止该线程）。 </li>
<li>unit 是一个枚举，表示 keepAliveTime 的单位（有NANOSECONDS, MICROSECONDS, MILLISECONDS, SECONDS, MINUTES, HOURS, DAYS，7个可选值）。 </li>
<li>workQueue 表示存放任务的队列（存放需要被线程池执行的线程队列）。 </li>
<li>handler 拒绝策略（添加任务失败后如何处理该任务）</li>
</ul>
<h4 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h4><ul>
<li>1、线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</li>
<li>2、当调用 execute() 方法添加一个任务时，线程池会做如下判断：<ul>
<li>a. 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</li>
<li>b. 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列。</li>
<li>c. 如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建线程运行这个任务；</li>
<li>d. 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常，告诉调用者“我不能再接受任务了”。</li>
</ul>
</li>
<li>3、当一个线程完成任务时，它会从队列中取下一个任务来执行。</li>
<li>4、当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</li>
</ul>
<p>这个过程说明，并不是先加入任务就一定会先执行。假设队列大小为4，corePoolSize为2，maximumPoolSize为6，那么当加入15个任务时，执行的顺序类似这样：首先执行任务 1、2，然后任务3~6被放入队列。这时候队列满了，任务7、8、9、10 会被马上执行，而任务 11~15则会抛出异常。最终顺序是：1、2、7、8、9、10、3、4、5、6。当然这个过程是针对指定大小的ArrayBlockingQueue<runnable>来说，如果是LinkedBlockingQueue<runnable>，因为该队列无大小限制，所以不存在上述问题。</runnable></runnable></p>
<h4 id="线程池创建"><a href="#线程池创建" class="headerlink" title="线程池创建"></a>线程池创建</h4><p>Executors.newCachedThreadPool();        //创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE<br><br>Executors.newSingleThreadExecutor();   //创建容量为1的缓冲池<br><br>Executors.newFixedThreadPool(int);    //创建固定容量大小的缓冲池<br></p>
</div></article><div class="tags"></div><div class="paginator"><a href="/2016/09/24/2016-03-17-EventBus/" class="prev"><i class="iconfont icon-left"></i><span> 上一页</span></a><a href="/2016/09/24/hello-world/" class="next"><span>下一页</span><i class="iconfont icon-right"></i></a></div></section><footer><div class="copyright"><p class="power">Powered by <a href="https://hexo.io/">Hexo</a> and Theme by <a href="https://github.com/ahonn/hexo-theme-even"> Even</a></p><p class="since">&copy;2016<span class="heart"><i class="iconfont icon-heart"></i></span><span class="author">Holo Wang</span></p></div><label id="back2top"><i class="iconfont icon-up"></i></label></footer></div><script src="/js/zepto.min.js"></script><script src="/js/theme.js"></script></body></html>